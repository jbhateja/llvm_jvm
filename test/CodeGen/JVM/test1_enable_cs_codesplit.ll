; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py

; RUN: llc < %s -enable-cs-codesplit | FileCheck %s --check-prefix=HOST-WRAPPER -match-full-lines
; RUN: llc < %s -mtriple=jvm32-unknown-unknown -jvm-candidate-checker | FileCheck %s --check-prefix=JVM -match-full-lines

@.str = private unnamed_addr constant [13 x i8] c"Res = %d...\0A\00", align 1

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @funcAdd(i32 %val) #0 {
; HOST-WRAPPER-LABEL: funcAdd:
; HOST-WRAPPER:       # %bb.0: # %entry
; HOST-WRAPPER-NEXT:    subq $280, %rsp # imm = 0x118
; HOST-WRAPPER-NEXT:    .cfi_def_cfa_offset 288
; HOST-WRAPPER-NEXT:    movl %edi, {{[0-9]+}}(%rsp)
; HOST-WRAPPER-NEXT:    movl %edi, {{[0-9]+}}(%rsp)
; HOST-WRAPPER-NEXT:    movq $.L__unnamed_1, {{[0-9]+}}(%rsp)
; HOST-WRAPPER-NEXT:    movq $.L__unnamed_2, {{[0-9]+}}(%rsp)
; HOST-WRAPPER-NEXT:    leaq {{[0-9]+}}(%rsp), %rdi
; HOST-WRAPPER-NEXT:    movl $.L__unnamed_1, %esi
; HOST-WRAPPER-NEXT:    movl $.L__unnamed_2, %edx
; HOST-WRAPPER-NEXT:    callq jvm_wrapper_static_method_call
; HOST-WRAPPER-NEXT:    addq $280, %rsp # imm = 0x118
; HOST-WRAPPER-NEXT:    retq
entry:
  %src = alloca [10 x i32], align 16
  %dst = alloca [10 x i32], align 16
  %0 = bitcast [10 x i32]* %src to i8*
  call void @llvm.memset.p0i8.i64(i8* align 16 %0, i8 10, i64 40, i1 false)
  %1 = bitcast [10 x i32]* %dst to i8*
  %2 = bitcast [10 x i32]* %src to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %1, i8* align 16 %2, i64 40, i1 false)
  %arrayidx = getelementptr inbounds [10 x i32], [10 x i32]* %dst, i64 0, i64 3
  %3 = load i32, i32* %arrayidx, align 4
  %add = add nsw i32 %3, %val
  ret i32 %add
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1) #1

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @main() #0 {
; HOST-WRAPPER-LABEL: main:
; HOST-WRAPPER:       # %bb.0: # %entry
; HOST-WRAPPER-NEXT:    pushq %rax
; HOST-WRAPPER-NEXT:    .cfi_def_cfa_offset 16
; HOST-WRAPPER-NEXT:    movl $100, %edi
; HOST-WRAPPER-NEXT:    callq funcAdd
; HOST-WRAPPER-NEXT:    movl %eax, %ecx
; HOST-WRAPPER-NEXT:    movl $.L.str, %edi
; HOST-WRAPPER-NEXT:    xorl %eax, %eax
; HOST-WRAPPER-NEXT:    movl %ecx, %esi
; HOST-WRAPPER-NEXT:    callq printf
; HOST-WRAPPER-NEXT:    popq %rcx
; HOST-WRAPPER-NEXT:    retq
entry:
  %call = call i32 @funcAdd(i32 100)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i32 %call)
  ret i32 %call1
}

declare dso_local i32 @printf(i8*, ...)
attributes #0 = { noinline nounwind uwtable}
attributes #1 = { argmemonly nounwind }
