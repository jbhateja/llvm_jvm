; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py

; RUN: llc < %s -mtriple=jvm32-unknown-unknown | FileCheck %s --check-prefix=JVM -match-full-lines

%struct.S1 = type { [10 x i32] }

; Function Attrs: noinline nounwind
define dso_local i32 @test(i32 %init) #0 {
; JVM:       new AoCClass1
; JVM-NEXT:    dup
; JVM-NEXT:    invokenonvirtual AoCClass1/<init>()V
; JVM-NEXT:    astore 2
; JVM-NEXT:    ldc 0
; JVM-NEXT:    istore 3
; JVM-NEXT:  LBB0_1:
; JVM-NEXT:    iload 3
; JVM-NEXT:    istore 4
; JVM-NEXT:    iload 4
; JVM-NEXT:    ldc 9
; JVM-NEXT:    if_icmpgt LBB0_4
; JVM-NEXT:    goto LBB0_2
; JVM-NEXT:  LBB0_2:
; JVM-NEXT:    aload 2
; JVM-NEXT:    getfield AoCClass1/f0 [I
; JVM-NEXT:    iload 4
; JVM-NEXT:    iload 0
; JVM-NEXT:    iastore
; JVM-NEXT:    iload 4
; JVM-NEXT:    iconst_1
; JVM-NEXT:    iadd
; JVM-NEXT:    istore 14
; JVM-NEXT:    iload 14
; JVM-NEXT:    istore 3
; JVM-NEXT:    goto LBB0_1
; JVM-NEXT:  LBB0_4:
; JVM-NEXT:    ldc 0
; JVM-NEXT:    istore 5
; JVM-NEXT:    ldc 0
; JVM-NEXT:    istore 6
; JVM-NEXT:  LBB0_5:
; JVM-NEXT:    iload 6
; JVM-NEXT:    istore 7
; JVM-NEXT:    iload 5
; JVM-NEXT:    istore 8
; JVM-NEXT:    iload 7
; JVM-NEXT:    ldc 9
; JVM-NEXT:    iload 8
; JVM-NEXT:    istore 9
; JVM-NEXT:    if_icmpgt LBB0_8
; JVM-NEXT:    goto LBB0_6
; JVM-NEXT:  LBB0_6:
; JVM-NEXT:    aload 2
; JVM-NEXT:    getfield AoCClass1/f0 [I
; JVM-NEXT:    iload 7
; JVM-NEXT:    iaload
; JVM-NEXT:    istore 11
; JVM-NEXT:    iload 8
; JVM-NEXT:    iload 11
; JVM-NEXT:    iadd
; JVM-NEXT:    istore 12
; JVM-NEXT:    iload 7
; JVM-NEXT:    iconst_1
; JVM-NEXT:    iadd
; JVM-NEXT:    istore 13
; JVM-NEXT:    iload 12
; JVM-NEXT:    istore 5
; JVM-NEXT:    iload 13
; JVM-NEXT:    istore 6
; JVM-NEXT:    goto LBB0_5
; JVM-NEXT:  LBB0_8:
; JVM-NEXT:    iload 9
; JVM-NEXT:    istore 10
; JVM-NEXT:    iload 10
; JVM-NEXT:    ireturn
entry:
  %obj = alloca %struct.S1, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %f1 = getelementptr inbounds %struct.S1, %struct.S1* %obj, i32 0, i32 0
  %arrayidx = getelementptr inbounds [10 x i32], [10 x i32]* %f1, i32 0, i32 %i.0
  store i32 %init, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc7, %for.end
  %sum.0 = phi i32 [ 0, %for.end ], [ %add, %for.inc7 ]
  %i1.0 = phi i32 [ 0, %for.end ], [ %inc8, %for.inc7 ]
  %cmp3 = icmp slt i32 %i1.0, 10
  br i1 %cmp3, label %for.body4, label %for.end9

for.body4:                                        ; preds = %for.cond2
  %f15 = getelementptr inbounds %struct.S1, %struct.S1* %obj, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [10 x i32], [10 x i32]* %f15, i32 0, i32 %i1.0
  %0 = load i32, i32* %arrayidx6, align 4
  %add = add nsw i32 %sum.0, %0
  br label %for.inc7

for.inc7:                                         ; preds = %for.body4
  %inc8 = add nsw i32 %i1.0, 1
  br label %for.cond2

for.end9:                                         ; preds = %for.cond2
  ret i32 %sum.0
}

attributes #0 = { noinline nounwind}
